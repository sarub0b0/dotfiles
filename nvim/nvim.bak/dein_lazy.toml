#[[plugins]]
#repo = 'jiangmiao/auto-pairs'

#[[plugins]]
#repo = 'Shougo/neoyank.vim'
#on_path = '.*'

[[plugins]]
repo = 'Shougo/neosnippet'
hook_source = '''
    " Plugin key-mappings.
    " Note: It must be "imap" and "smap".  It uses <Plug> mappings.
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    smap <C-k>     <Plug>(neosnippet_expand_or_jump)
    xmap <C-k>     <Plug>(neosnippet_expand_target)

    " SuperTab like snippets behavior.
    " Note: It must be "imap" and "smap".  It uses <Plug> mappings.
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    "imap <expr><TAB>
    " \ pumvisible() ? "\<C-n>" :
    " \ neosnippet#expandable_or_jumpable() ?
    " \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

    " For conceal markers.
    if has('conceal')
      set conceallevel=2 concealcursor=niv
    endif
'''
depends = ['neosnippet-snippets', 'deoplete.nvim']

#[[plugins]]
#repo = 'Shougo/neocomplete'
#if = 'has("lua")'

#[[plugins]]
#repo = 'Shougo/denite.vim'

#[[plugins]]
#repo = 'Shougo/unite.vim'
#depends = 'neomru.vim'

[[plugins]]
repo = 'fatih/vim-go'
on_ft = 'go'

[[plugins]]
repo = 'zchee/deoplete-go'
on_ft = 'go'

[[plugins]]
repo = 'othree/html5.vim'
on_ft = 'html'

[[plugins]]
repo = 'cespare/vim-toml'
on_ft = 'toml'

[[plugins]]
repo = 'rcmdnk/vim-markdown'
on_ft = 'md'
hook_source = '''
    let g:vim_markdown_frontmatter =1
    let g:vim_markdown_math = 1
'''
[[plugins]]
repo = 'rhysd/vim-clang-format'
on_ft = ['c', 'cpp', 'cmake', 'h', 'hpp']

[[plugins]]
repo = 'google/vim-maktaba'

[[plugins]]
repo = 'google/vim-codefmt'

[[plugins]]
repo = 'google/vim-glaive'

#[[plugins]]
#repo = 'Shougo/neocomplcache'

[[plugins]]
repo = 'vim-scripts/sudo.vim'

[[plugins]]
repo = 'thinca/vim-quickrun'
hook_source = '''
    let g:quickrun_config = get(g:, 'quickrun_config', {})

    let g:quickrun_config['_'] = {
                \   'runner': 'vimproc',
                \   'runner/vimproc/updatetime': 60,
                \   'outputter': 'error',
                \   'outputter/error/success': 'buffer',
                \   'outputter/error/error': 'quickfix',
                \   'outputter/buffer/close_on_empty': 1,
                \   'outputter/buffer/split': 'rightbelow 7',
                \   }

    let g:quickrun_config['allegro'] = {
                \      'command': 'clang',
                \      'cmdopt': '`pkg-config --cflags --libs allegro-5 allegro_acodec-5 allegro_audio-5 allegro_color-5 allegro_dialog-5 allegro_font-5 allegro_image-5 allegro_main-5 allegro_memfile-5 allegro_physfs-5 allegro_primitives-5 allegro_ttf-5`',
                \      'exec': '%c %o %s:p',
                \       }


    nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"

    let g:quickrun_no_default_key_mappings = 1
    nnoremap <Leader>r :cclose<CR>:write<CR>:QuickRun<Space>
    xnoremap <Leader>r :<C-U>cclose<CR>:<C-U>write<CR>gv:QuickRun<Space>
'''

[[plugins]]
repo = 'zchee/deoplete-clang'
hook_source = '''
    if has('mac')
        let g:deoplete#sources#clang#libclang_path = '/usr/local/opt/llvm/lib/libclang.dylib'
        let g:deoplete#sources#clang#clang_header = '/usr/local/opt/llvm/lib/clang'
    else
        let g:deoplete#sources#clang#libclang_path = '/usr/lib64/libclang.so'
        let g:deoplete#sources#clang#clang_header = '/usr/include/clang'
    endif
'''
on_ft = ['c', 'cpp', 'cmake', 'h', 'hpp']

[[plugins]]
repo = 'vim-latex/vim-latex'
hook_source = '''
    filetype plugin on
    filetype indent on
    set shellslash
    set grepprg=grep\ -nH\ $*
    let g:tex_flavor='latex'
    let g:Imap_UsePlaceHolders = 1
    let g:Imap_DeleteEmptyPlaceHolders = 1
    let g:Imap_StickyPlaceHolders = 0
    let g:Tex_DefaultTargetFormat = 'dvi'
    let g:Tex_MultipleCompileFormats='dvi,pdf'
    let g:Tex_FormatDependency_pdf = 'dvi,pdf'
    let g:Tex_CompileRule_dvi = 'platex -synctex=1 -interaction=nonstopmode -file-line-error $*'
    let g:Tex_CompileRule_pdf = 'dvipdfmx $*.dvi'
    let g:Tex_BibtexFlavor = 'upbibtex'
    let g:Tex_MakeIndexFlavor = 'upmendex $*.idx'
    let g:Tex_UseEditorSettingInDVIViewer = 1
    let g:Tex_ViewRule_dvi = 'open -a /Applications/Skim.app'
    let g:Tex_ViewRule_pdf = 'open -a /Applications/Preview.app'
'''
on_ft = 'tex'

[[plugins]]
repo = 'majutsushi/tagbar'
hook_source = '''
    let g:tagbar_width = 30
    let g:tagbar_autoshowtag = 1

    nmap <Leader>t :TagbarToggle<CR>
'''
#[[plugins]]
#repo = 'gilligan/vim-lldb'
#on_ft = ['c', 'cpp', 'cmake']

[[plugins]]
repo = 'zebult/auto-gtags.vim'

[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 'kana/vim-fakeclip'

[[plugins]]
repo = 'scrooloose/nerdtree'
hook_post_source = '''
    augroup NERDTreeCmd
        autocmd StdinReadPre * let s:std_in=1
        autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
    augroup END

    nnoremap <Space> <Nop>
    nnoremap <Space>n :NERDTree<CR>
'''

[[plugins]]
repo = 'scrooloose/nerdcommenter'
hook_source = '''
    filetype plugin on

    let g:NERDSpaceDelims = 1
    let g:NERDDefaultAlign = 'left'

    map <Leader> <Nop>
    nmap <Leader>c <Plug>NERDCommenterToggle
    xmap <Leader>c <Plug>NERDCommenterToggle
'''

[[plugins]]
repo = 'kana/vim-submode'
hook_post_source = '''
    call submode#enter_with('bufmove', 'n', '', 's>', '<C-w>>')
    call submode#enter_with('bufmove', 'n', '', 's<', '<C-w><')
    call submode#enter_with('bufmove', 'n', '', 's+', '<C-w>+')
    call submode#enter_with('bufmove', 'n', '', 's-', '<C-w>-')
    call submode#map('bufmove', 'n', '', '>', '<C-w>>')
    call submode#map('bufmove', 'n', '', '<', '<C-w><')
    call submode#map('bufmove', 'n', '', '+', '<C-w>+')
    call submode#map('bufmove', 'n', '', '-', '<C-w>-')
'''

[[plugins]]
repo = 'Shougo/deoplete.nvim'
hook_add = '''
    let g:deoplete#enable_at_startup = 1
'''

[[plugins]]
repo = 'w0rp/ale'
hook_source = '''
    " エラー行に表示するマーク
    let g:ale_sign_error = '⨉'
    let g:ale_sign_warning = '⚠'
    " エラー行にカーソルをあわせた際に表示されるメッセージフォーマット
    let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
    " エラー表示の列を常時表示
    let g:ale_sign_column_always = 1

    " ファイルを開いたときにlint実行
    let g:ale_lint_on_enter = 0
    " ファイルを保存したときにlint実行
    let g:ale_lint_on_save = 1
    " 編集中のlintはしない
    let g:ale_lint_on_text_changed = 0

    let g:ale_lint_on_insert_leave = 1

    " lint結果をロケーションリストとQuickFixには表示しない
    " 出てると結構うざいしQuickFixを書き換えられるのは困る
    let g:ale_set_loclist = 0
    let g:ale_set_quickfix = 1
    let g:ale_open_list = 1
    let g:ale_keep_list_window_open = 0
'''

